package main

import "sort"

type DSU struct {
	n        int
	size     []int
	root     []int
	infected []int
}

// use union-find to grope connective nodes
// we need to find a connective cluster has only one infected node
func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	sort.Ints(initial)

	dsu := Constructor(n)

	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			if graph[i][j] == 1 {
				dsu.union(i, j)
			}
		}
	}

	for _, v := range initial {
		root := dsu.find(v)
		// to record the number of the infected nodes
		dsu.infected[root]++
	}

	nums := 0
	res := -1

	for _, v := range initial {
		root := dsu.find(v)
		// the cluster has only one infected node is what we are looking for
		if dsu.infected[root] == 1 {
			if nums < dsu.size[root] {
				nums = dsu.size[root]
				res = v
			}
		}
	}
	if res == -1 {
		return initial[0]
	}
	return res
}

func Constructor(n int) DSU {
	root := make([]int, n)
	for i := 0; i < n; i++ {
		root[i] = i
	}
	size := make([]int, n)
	for i := 0; i < n; i++ {
		size[i] = 1
	}
	dsu := DSU{
		n:        n,
		size:     size,
		root:     root,
		infected: make([]int, n),
	}
	return dsu
}

func (this DSU) find(x int) int {
	if this.root[x] != x {
		this.root[x] = this.find(this.root[x])
	}
	return this.root[x]
}

func (this DSU) union(x, y int) {
	rootX := this.find(x)
	rootY := this.find(y)
	if rootX == rootY {
		return
	}
	if this.size[rootX] < this.size[rootY] {
		this.root[rootX] = rootY
		this.size[rootY]++
	} else {
		this.root[rootY] = rootX
		this.size[rootX]++
	}
}
